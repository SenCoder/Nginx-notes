### Redis 数据结构

- string 数组，预分配冗余空间的方式减少动态内存分配【ArrayList】
- list 采用类似于链表的方式存储数据，意味着其插入和删除非常快，通常作为异步队列使用【LinkedList】
- set
- hash 字典
- zset 有序列表



list/set/hash/zset 这四种数据结构是容器型数据结构，具有如下通用规则：

1. 如果容器不存在，就自动创建后进行操作
2. 如果容器里没有元素了，就立即删除，释放内存



### 应用一：Redis 分布式锁

单个个进程内，为了保证代码在同一时间段内只被一个线程访问，我们使用类似 synchronized 之类的关键字就可以实现同步；但在分布式的环境中，如果需要保证多个节点的代码同步执行，就需要考虑**分布式锁**。分布式锁的实现方式有多种：

- Memcache 实现分布式锁
- Redis 分布式锁
- Zookeeper 分布式锁

**分布式锁**本质上要实现的目标就是在 redis 里面占一个坑，当其他进程也要来占时，发现已经被占用，只好放弃或稍后重试。

```redis
setnx lock:codehole true
expire lock:codehole 5
del lock:codehole
```

通常我们使用 setnx 加锁，del 解锁就可以；但是如果加锁后，解锁前程序出现了异常，解锁不执行就陷入了死锁；

于是我们用  expire 加上过期时间；但是如果在expire 之前服务器进程挂掉了怎么办？

这些问题根源在于 setnx 和 expire 是两条指令，而不是原子指令，不能保证一起执行。

能否用事务解决这一问题呢？不行，因为 **expire 依赖 setnx 的执行结果**。如果 setnx 没有抢到锁，expire 不执行，而事务里面没有 if-else 分支逻辑。

为了解决这个问题，redis 2.8 引入了set 指令的扩展参数，以实现原子指令。

```redis
setnx lock:codehole true ex 5 nx
```



Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁，但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻辑执行完之间拿到了锁。

```python
tag = random.nextint()  # 随机数
if redis.set(key, tag, nx=True, ex=5):
    do_something()
    redis.delifequals(key, tag)  # 假想的 delifequals 指令...
```

但是这也不是一个完美的方案，它只是相对安全一点，因为如果真的超时了，当前线程的逻辑没有执行完，其它线程也会乘虚而入。

怎么办呢？可以考虑开启守护线程给该锁进行续航。

问题依然存在：比如在 Sentinel 集群中，redis 主节点挂掉时，从节点会取而代之，客户端上却并没有明显感知。原先第一个客户端在主节点中申请成功了一把锁，但是这把锁还没有来得及同步到从节点，主节点突然挂掉了。然后从节点变成了主节点，这个新的节点内部没有这个锁，所以当另一个客户端过来请求加锁时，立即就批准了。这样就会导致系统中同样一把锁被两个客户端同时持有，不安全性由此产生。解决办法：Redlock 算法。



我们讲了分布式锁的问题，但是没有提到客户端在处理请求时加锁没加成功怎么办。一般有 3 种策略来处理加锁失败：

1. 直接抛出异常，通知用户稍后重试；
2. sleep 一会再重试；
3. 将请求转移至延时队列，过一会再试；

### 应用二：消息队列

Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用`rpush/lpush`操作入队列，使用`lpop 和 rpop`来出队列。



我们通常都使用 rabbitMQ 或者 Kafka 作为消息队列中间件，它们都是专业的消息中间件，集成了庞大的功能。Redis 的好处是在简单的场景下可以使用 redis 轻松搞定。Redis 的消息队列不是专业的消息队列，它没有非常多的高级特性，没有ack保证，如果对消息队列可靠性有极致的追求，它不适合。



客户端是通过队列的 pop 操作来获取消息，然后进行处理。处理完了再接着获取消息，再进行处理。如此循环往复，这便是作为队列消费者的客户端的生命周期。 可是如果队列空了，客户端就会陷入 pop 的死循环，不停地 pop，没有数据，接着再 pop，又没有数据。这就是浪费生命的空轮询。空轮询不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高，如果这样空轮询的客户端有几十来个，Redis 的慢查询可能会显著增多。 通常我们使用 sleep 来解决这个问题，让线程睡一会，睡个 1s 钟就可以了。不但客户端的 CPU 能降下来，Redis 的 QPS 也降下来了。



睡眠的办法可以解决问题。但是有个小问题，那就是睡眠会导致消息的延迟增大。如果只有 1 个消费者，那么这个延迟就是 1s。如果有多个消费者，这个延迟会有所下降，因为每个消费者的睡觉时间是岔开来的。 有没有什么办法能显著降低延迟呢？你当然可以很快想到：那就把睡觉的时间缩短点。这种方式当然可以，不过有没有更好的解决方案呢？当然也有，那就是 blpop/brpop。 这两个指令的前缀字符b代表的是blocking，也就是阻塞读。 阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用blpop/brpop替代前面的lpop/rpop，就完美解决了上面的问题。



你以为上面的方案真的很完美么？先别急着开心，其实他还有个问题需要解决。 什么问题？—— 空闲连接的问题。 如果线程一直阻塞在哪里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候blpop/brpop会抛出异常来。 所以编写客户端消费者的时候要小心，注意捕获异常，还要重试。



### 高级数据结构 HyperLogLog

HyperLogLog 为了解决基数统计问题而存在【比如当系统需要统计 UV这样的数据】，满足精度不高的统计需求。

```redis
pfadd key element
pfcount

pfmerge
```

pf 是发明人姓名首字母的缩写。

HyperLogLog 需要占据 12K 的存储空间，一般认为不适合用来统计单个用户的数据，否则在拥有上亿用户的时候非常惊人。

### 限流



